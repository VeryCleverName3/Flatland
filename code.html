<html>
<body>
  <a href = "main.js">Click this to see the main logic (Look at the math done to draw polygons, it's pretty cool)</a>
  <br>
  <br>
  <a href = "worldCreation.js">Click here to see how the world is generated</a>
  <p>Main.js is where logic takes place. It sets up an interval that calls updateOverworld() 60 times per second. updateOverworld performs all of the functions that call the functions for updating game data in the arrays that are populated by the instantiation of any Entity object, which is a superclass used by the Player, Enemy, and NPC subclasses. One of the more interesting functions in the Entity class is the draw function, which I use to draw the polygons. This is a function that calls another function I wrote to take a number of sides as an argument and draw a regular polygon just given that information. This is difficult to do algorithimically because HTML5 currently does not support drawing polygons or even drawing lines at an angle. It only allows lines to be drawn from point to point, given as (x, y) coordinates. To transform the number of sides into a polygon, I calculated the interior angle of each of these polygons, and used this with a looping structure. Inside of these loops, I use tangent to get a slope for the lines of these angles. Because direction of these lines needs to be reflected, I use the angle that was used to calculate the slope to determine whether or not to assign a variable to flip the direction to its opposite. Now that the code has the slope and intercept of all lines that intersect the center of the polygon and the apothems of all polygon sides, I can use the pythagorean theorem with the ratios of slope / (slope + 1) and 1 / (slope + 1) to find the x and y coordinates of the apothems. With this information, we can use similar methods to find the slope of lines intersecting the apothems and the corners of the polygons. The side length can also be easily calculated given the number of sides. Another interesting part of the code is the efficient array management and enemy spawns. While not technically difficult, it reduces lag by using a form of occulsion culling, in which enemies outside of the player's view are deleted by setting all references to null and using garbage collection. A clean arrays function I wrote and call several times in the updateOverworld function automatically removes null references and shortens the arrays to minimum lengths. The NPCs are created with a contructor that inherits from the Entity class. They have a text property that allows for a constructor to contain the dialogue they say. I also included an action property that is meant to be a function. On instantiation. it is a blank function. However, when changed, it is called at the end of an NPC's dialogue. The battling system clears the interval used to update the 'overworld', effectively pausing it, and then starts up a new interval for the battle. This draws the player and enemy with he aforementioned polygon drawing method. Insults the enemy says are randomly drawn form a pool stored in an array. Insults the player says are stored in an array that is a property of the player. It is multidimensional, each element containing the insult text and the number of sides it is effective against. For example, the "Don't be so square" insult is stored in this array as []"Don't be so square", 4]. I wrote the critical system so that if the sides effective against is -1, it's effective 1x against everything. worldCreation.js just uses the contructors in the main.js file to create NPCs and toggle random enemy spawns. Intercations and collisions are done using the pythagorean theorem in a function I wrote called distance. Distance() takes two entities as arguments and returns the in-game distance between them. (I say in-game because I had to use different coordinate systems for the game and display, as many displays have different resolutions. To account for this, I set the canvas size to the height of the window, then multiply the coordinate by the square's size / 100, so the visible screen is a 100 * 100 grid in the code) This is only a brief overview of a very small amount of the code, so I still recommend looking at and reading the code, as the function names are either very clear or well documented.</p>
</body>
</html>
